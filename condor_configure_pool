#!/usr/bin/python
#   Copyright 2008 Red Hat, Inc.
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

import getopt
import os
import sys
import re
import signal
from qmf.console import Session

feature_list = {}

def exit_signal_handler(signum, frame):
   result = group_obj.RemoveFeatures(feature_list)
   if result.status != 0:
      print 'Error: Problem removing features (%d, %s)' % (result.status, result.text)
   sys.exit(0)

def print_help(name, sess):
   print 'usage: %s [-h|--help] -b|--broker <broker> [-p|--port <port>] [-g|--group|-n|--node name] action [-f|--features feature[,feature,...]] [-p|--params param=1,param2=string,...] ' % os.path.basename(name)
   print '  <broker> - The ip/hostname of the broker used by the configuration store'
   print '  <port> - The port of the broker used by the configuration store'
   print '  -g - The name of the group to configure'
   print '  -n - The name of the specific node to configure'
   print '  -h - Print help'
   print '\naction:'
   print '  -a|--add    - Add the feature(s) to the group/node'
   print '  -d|--delete - Remove the feature(s) from the group/node'
   print '  -l|--list   - List configurations.  If provided without a specific'
   print '                name, prints the list of nodes being managed.  If'
   print '                a name is provided, print the list of features'
   print '                and parameters for the provided name.  If provided'
   print '                with one or more features or parameters in addition'
   print '                to a name, then print the specific configurations'
   print '                for those features and/or parameters for that name'
   print '\navailable features:'
   if sess != []:
      features = sess.getObjects(_class='Feature', _package='mrg.grid.config')
      if features != []:
         for feat in features:
            id = feat.getIndex()
            result = feat.GetName()
            if result.status != 0:
               print 'Error: Unable to retrieve feature name for feature id "%s"' % id
            else:
               print '%-21s\b' % result.outArgs['name']
      else:
         print 'Unable to retrieve list of features'

def get_group(sess, store, name):
#   result = store.GetGroup({'Name': name})
   print 'Group name: %s' % name
   result = store.GetGroupByName(name)
   if result.status != 0:
      print 'Error: Unable to get group info from data store (%d, %s)' % (result.status, result.text)
      return None
   else:
      return sess.getObjects(_objectId=result.outArgs['obj'])

def print_feature_info(sess, store, feature_name):
   result = store.GetFeature(feature_name)
   if result.status != 0:
      print 'Error: Failed to retrieve configration for feature "%s" (%d, %s)' % (feature_name, result.status, result.text)
   else:
      # Retrieve the Feature ID
      obj = sess.getObjects(_objectId=result.outArgs['obj'])
      if obj == []:
         print 'Error: Failed to retrieve group object with id "%s"' % result.outArgs['obj']
         return

      feature_obj = obj[0]
      id = feature_obj.getIndex()
      print 'Feature ID: %d' % id

      # Retrieve the parameter list
      result = feature_obj.GetParamsAsString()
      if result.status != 0:
         print 'Error: Failed to retrieve feature parameters for feature "%s" (%d, %s)' % (feature_name, result.status, result.text)
      else:
#         params = result.outArgs['list']
         params = eval(result.outArgs['params'])
         print 'Feature Parameters:'
         for param in params.keys():
            print '%s = %s' % (param, params[param])

      # Retrieve any features this feature includes upon
#      result = feature_obj.GetFeatures()
      result = feature_obj.GetFeaturesAsString()
      if result.status != 0:
         print 'Error: Failed to retrieve included features for feature "%s" (%d, %s)' % (feature_name, result.status, result.text)
      else:
#         inc_features = result.outArgs['list']
         inc_features = eval(result.outArgs['features'])
         print 'Included Features (name: priority):'
         for feat in inc_features.keys():
           print '%s: %s' % (feat, inc_features[feat])

      # Retrieve any features this feature conflicts with
      result = feature_obj.GetConflicts()
      if result.status != 0:
         print 'Error: Failed to retrieve feature conflicts for feature "%s" (%d, %s)' % (feature_name, result.status, result.text)
      else:
         conflicts = result.outArgs['list']
         print 'Conflicting Features:'
         for conf in conflicts.keys():
            print '%s' % conf

      # Retrieve any features this feature depends on
      result = feature_obj.GetDepends()
      if result.status != 0:
         print 'Error: Failed to retrieve feature dependencies for feature "%s" (%d, %s)' % (feature_name, result.status, result.text)
      else:
         depends = result.outArgs['list']
         print 'Feature Depedencies (name: priority):'
         for dep in depends.keys():
           print '%s: %s' % (dep, depends[dep])

def configure_node_schedulers(params):
   response = 'y'

   if raw_input('Modify which schedulers this group can submit to [y/N] ? ').lower() == 'y':
      def_sched = raw_input('Enter the name of the default scheduler: ')
      if def_sched != '':
         if raw_input('Is this a High Available Scheduler [y/N] ? ').lower() == 'y':
            params['SCHEDD_NAME'] = def_sched
         else:
            params['SCHEDD_HOST'] = def_sched
      addl_scheds = raw_input('Enter a comma separated list of additional schedulers that will accept job submissions: ')
      if addl_scheds != '':
         params['HOSTALLOW_WRITE_STARTD'] = addl_scheds
         params['HOSTALLOW_READ_STARTD'] = addl_scheds
         params['HOSTALLOW_WRITE_DAEMON'] = addl_scheds
         params['HOSTALLOW_READ_DAEMON'] = addl_scheds

def configure_qmf_broker(params):
   response = 'y'

   response = raw_input('Change the broker information this group uses to communicate with the Management Console [y/N] ? ')
   if response.lower() == 'y':
      # Remove previous configuration it if exists
      value = raw_input('Enter the hostname of the AMQP broker this group will use to communicate with the Management Console: ')
      params['QMF_BROKER_HOST'] = value
      value = raw_input('Enter the port the AMQP broker listens on (Default: 5672): ')
      if value != '':
         params['QMF_BROKER_PORT'] = value

group_obj = []

def main(argv=None):
   if argv is None:
      argv = sys.argv

   action = ''
   features = ''
   broker_ip = ''
   name = ''
   node = ''
   port = '5672'
   param_list = {}
   group_config = {}
   config_store = []
   session = []
   need_print_help = False

   # Set signal handlers
   signal.signal(signal.SIGINT, exit_signal_handler)
   signal.signal(signal.SIGTERM, exit_signal_handler)

   long_opts = ['add', 'broker=', 'delete', 'features=', 'group=', 'help',
                'list', 'node=', 'params=', 'port=']
   try:
      opts, args = getopt.getopt(argv[1:], 'ab:df:g:hln:p:o:', long_opts)
   except getopt.GetoptError, error:
      print str(error)
      return(1)

   for option, arg in opts:
      if option in ('-a', '--add'):
         if action != '':
            print 'Only 1 action may be specified'
            return(1)
         action = 'add'
      if option in ('-b', '--broker'):
         broker_ip = arg
      if option in ('-d', '--delete'):
         if action != '':
            print 'Only 1 action may be specified'
            return(1)
         action = 'remove'
      if option in ('-f', '--features'):
         features = arg
      if option in ('-g', '--group'):
         if node != '':
            print 'Can only configure 1 node or group at a time'
            return(1)
         name = arg
      if option in ('-h', '--help'):
         need_print_help = True
      if option in ('-l', '--list'):
         if action != '':
            print 'Only 1 action may be specified'
            return(1)
         action = 'list'
      if option in ('-n', '--node'):
         if name != '':
            print 'Can only configure 1 node or group at a time'
            return(1)
         node = arg
      if option in ('-o', '--port'):
         port = arg
      if option in ('-p', '--params'):
         for param_pair in arg.split(','):
            param = param_pair.split('=')
            if len(param) != 2:
               print 'Invalid input "%s".  Skipping' % param_pair
               continue
            param_list[param[0]] = param[1]

   # Connect to the configuration store
   if broker_ip == '':
      if need_print_help == True:
         print_help(argv[0], session)
         return(0)
      print 'No broker specified.  Exiting'
      return(0)

   session = Session()
   try:
      broker = session.addBroker('amqp://%s:%s' % (broker_ip, port))
   except:
      print 'Unable to connect to broker "%s"' % broker_ip
      return(1)

   # Retreive the config store object
   config_store = session.getObjects(_class='Store', _package='mrg.grid.config')
   if config_store == []:
      print 'Unable to contact Configuration Store'
   else:
      config_store = config_store[0]
       
   if need_print_help == True:
      print_help(argv[0], session)
      return(0)

   if config_store == []:
      return(1)

   # If configuring a single node, grab that node's identity group and
   # act upon that
   if node != '':
      result = config_store.GetNode(node)
      if result.status != 0:
         print 'Error: Unable to get node "%s" from data store (%d, %s)' % (node, result.status, result.text)
         return(1)
      else:
         ref = session.getObjects(_objectId=result.outArgs['obj'])
         if ref == []:
            print 'Error: Unable to find node object with id "%s" (%d, %s)' % (node, result.status, result.text)
         else:
            obj = ref[0]
            result = obj.GetIdentityGroup()
            if result.status != 0:
               print 'Error: Unable to the identity group for node "%s" (%d, %s)' % (node, result.status, result.text)
            else:
               idgroup_ref = session.getObjects(_objectId=result.outArgs['group'])
               if ref == []:
                  print 'Error: Unable to find identity group with id "%s" (%d, %s)' % (result.outArgs['obj'], result.status, result.text)
               else:
                  result = idgroup_ref[0].GetName()
                  name = result.outArgs['name']

   # Perform list opertions
   if action == 'list':
      if name == '' and features == '':
         node_list = []
         node_list = session.getObjects(_class='Node', _package='mrg.grid.config')
         if node_list == []:
            return(1)

         print 'Nodes being managed:'
         for obj in node_list:
            print obj.getIndex()
      elif name != '' and features == '':
         # Get the group object from the store
         obj = get_group(session, config_store, name)
         if obj == None or obj == []:
            return(1)
         group_obj = obj[0]

         print 'Configuration for %s:' % name

         # Get the list of nodes included in this group
#         result = group_obj.GetMembership()
#         if result.status != 0:
#            print 'Error: Failed to retrieve included nodes for group %s (%d, %s)' % (name, result.status, result.text)
#         else:
#            print 'Nodes included:'
#            for group_node in result.outArgs['list'].keys():
#               print group_node

         # Get the features configured for this group
#         result = group_obj.GetFeatureSet()
         result = group_obj.GetFeaturesAsString()
         if result.status != 0:
            print 'Error: Failed to retrieve included features for group %s (%d, %s)' % (name, result.status, result.text)
         else:
            print 'Features Configured:'
#            for feature in result.outArgs['features'].keys():
            for feature in eval(result.outArgs['features'].keys()):
               print feature

         # Get parameters specific to this group
         result = group_obj.GetParamsAsString()
         if result.status != 0:
            print 'Error: Failed to retrieve included parameters for group %s (%d, %s)' % (name, result.status, result.text)
         else:
            print 'Attributes Configured:'
#            params = result.outArgs['customParams']
            params = eval(result.outArgs['params'])
            for key in params.keys():
               print '%s = %s' % (key, params[key])
      elif features != '':
         # Provide the configuration for the features
         for feat in features.split(','):
            print 'Configuration for feature %s:' % feat
            print_feature_info(config_store, feat)
            
      return(0)

   if name == '':
      print 'No name supplied.  Exiting'
      print_help(argv[0], session)
   elif action == '':
      print 'No action specified.  Exiting'
      print_help(argv[0], session)
   elif features == '' and param_list == {}:
      print 'No features/parameters specified.  Exiting'
      print_help(argv[0], session)
   else:
      # Query the store to get the group
      obj = get_group(session, config_store, name)
      if obj == None or obj == []:
         return(1)
      group_obj = obj[0]

      # Generate the list of features to act upon
      for feature in features.split(','):
         feature_list[feature] = 0
         
      # Configure which schedulers the node can submit to
      configure_node_schedulers(param_list)

      # Configure the AMQP broker used to communicate with the Management
      # Console
      configure_qmf_broker(param_list)

      if raw_input('\nApply these changes [y/N] ? ').lower() == 'y':
         req_params = {}
#         result = group_obj.ModifyFeatureSet(action, feature_list)
         for feature in feature_list.keys():
            print "Adding feature '%s' to groupid '%s'" % (feature, group_obj)
            if action == 'add':
               result = group_obj.AddFeature(feature)
            else:
               result = group_obj.RemoveFeature(feature)
            if result.status != 0:
               print 'Error: Problem modifying features (%d, %s)' % (result.status, result.text)
               return(1)
            else:
#               req_params = result.outArgs['params']
               req_params = {}

         if req_params != {}:
            print 'The following parameters must be set for this configuration to be valid:'
            for param in req_params.keys():
               print '\nAttribute Name: %s' % param
               print 'Reason: %s' % req_params[param]
               value = raw_input('Value: ')
               param_list[param] = value
                  
         if param_list != {}:
#               result = group_obj.ModifyParams(action, param_list)
               for param in param_list.keys():
                  if action == 'add':
                     result = group_obj.AddParamMapping(param, param_list[param])
                  else:
                     result = group_obj.RemoveParamMapping(param)

                  if result.status != 0:
                     print 'Error: Problem modifying parameters (%d, %s)' % (result.status, result.text)
                     return(1)
         print 'Configuration applied'

         if raw_input('\nSave this configuration [y/N] ? ').lower() == 'y':
            config_name = raw_input('  Configuration Name: ')
            result = config_store.SaveConfiguration(config_name)
            if result.status != 0:
               print 'Error: Problem saving configuration in store (%d, %s)' % (result.status, result.text)
            else: 
               print 'Configuration saved with ID "%s"' % result.outArgs['configId']
               if raw_input('\nActivate this configuration [y/N] ? ').lower() == 'y':
                  result = config_store.ActivateConfiguration(config_name)
                  if result.status != 0:
                     print 'Error: Problem activating configuration (%d, %s)' % (result.status, result.text)
                  else: 
                     print 'Configuration activated'
      else:
         print 'Configuration not applied'

if __name__ == '__main__':
    sys.exit(main())
