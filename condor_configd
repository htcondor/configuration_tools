#!/usr/bin/python
#   Copyright 2008 Red Hat, Inc.
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

import os
import sys
import logging
import signal
import time
import socket
import threading
import getopt
import Queue
import random
import tempfile
import shutil
import stat
from qmf.console import Session, Console
from condorutils.log import *
from condorutils.readconfig import *
try:
   import pwd
except:
   pass


class Timer (threading.Thread):
   def __init__ (self, interval, function, args=[], kwargs={}):
      threading.Thread.__init__(self)
      self.interval = interval
      self.function = function
      self.args = args
      self.kwargs = kwargs
      self.setDaemon(True)
      self.finished = threading.Event()


   def stop (self):
      self.finished.set()
      self.join()


   def run (self):
      while not self.finished.isSet():
         self.finished.wait(self.interval)
         if not self.finished.isSet():
            self.function(*self.args, **self.kwargs)


class EventConsole(Console):
   def __init__(self):
      self.node = []
      self.logger_name = ''


   def config(self, node_name, log_name):
      self.node_name = node_name
      self.logger_name = log_name


   def event(self, broker, event):
      global version_queue

      if event.getClassKey().getClassName() == 'NodeUpdatedNotice':
         log(logging.DEBUG, self.logger_name, 'Received a NodeUpdatedNotice')
         args = event.getArguments()
         nodes = args['nodes']
         if self.node_name in nodes or '*' in nodes:
            log(logging.DEBUG, self.logger_name, 'The event is for this node')
            event_ver = int(args['version'])
            try:
               version_queue.put(event_ver, False)
            except Queue.Full, error:
               log(logging.INFO, self.logger_name, 'Configuration version queue full.  Discarding event for version "%d"' % event_ver)


class Service:
   def __init__(self):
      self.broker_ip = ''
      self.broker_port = 5672
      self.broker = None
      self.console = None
      self.session = None
      self.store = []
      self.agent = []
      self.interval = 0
      self.node_obj = []
      self.logger_name = ''
      self.filename = ''
      self.node_name = ''
      self.timer = None
      self.lock = threading.Lock()


   def init(self, node, name):
      self.console = EventConsole()
      self.session = Session(self.console, manageConnections=False, rcvObjects=False, rcvHeartbeats=False, rcvEvents=True)
      self.session.addEventFilter(package='com.redhat.grid.config', event='NodeUpdatedNotice')
      self.logger_name = name
      self.node_name = node
      self.managedfile = ''
      self.user = ''
      self.password = ''


   def config(self, filename, user='', password=''):
      self.user = user
      self.password = password

      if self.broker != None:
         self.session.delBroker(self.broker)
         self.broker = None

      if self.store != []:
         self.store = []

      if self.agent != []:
         self.agent = []

      try:
         val = read_condor_config('QMF_BROKER', ['HOST'])
         self.broker_ip = val['host']
      except ConfigError, error:
         # Broker host not defined, so exit
         log(logging.ERROR, self.logger_name, '%s.  Exiting' % error.msg)
         return(False)

      try:
         val = read_condor_config('QMF_BROKER', ['PORT'])
         self.broker_port = int(val['port'])
      except ConfigError, error:
         log(logging.DEBUG, self.logger_name, '%s. Using default (5672)' % error.msg)
         self.broker_port = 5672

      try:
         val = read_condor_config('QMF_CONFIGD', ['CHECK_INTERVAL'])
         self.interval = int(val['check_interval'])
      except ConfigError, error:
         log(logging.INFO, self.logger_name, '%s. Node configuration evaluation disabled' % error.msg)
         self.interval = 0

      if filename == '':
         try:
            self.managedfile = read_condor_config('LOCAL_CONFIG', ['FILE'])['file']
         except:
            log(logging.ERROR, self.logger_name, 'LOCAL_CONFIG_FILE not defined.  Unable to write configuration file')
            self.session.delBroker(self.broker)
            return(False)
      else:
         self.managedfile = filename
      log(logging.DEBUG, self.logger_name, 'Writing configuration file to "%s"' % self.managedfile)
       
      return(self.config_qmf_entities())


   def config_qmf_entities(self):
      if self.broker != None:
         try:
            self.session.delBroker(self.broker)
         except:
            self.broker = None

      if self.node_obj != None:
         self.node_obj = None

      if self.user != '' and self.password != '':
         broker_str = '%s/%s@%s:%d' % (self.user, self.password, self.broker_ip, self.broker_port)
      elif self.user != '':
         broker_str = '%s@%s:%d' % (self.user, self.broker_ip, self.broker_port)
      else:
         broker_str = '%s:%d' % (self.broker_ip, self.broker_port)

      try:
         self.broker = self.session.addBroker('amqp://%s' % broker_str)
         log(logging.DEBUG, self.logger_name, 'Connected to broker "%s"' % broker_str)
      except:
         log(logging.CRITICAL, self.logger_name, 'Unable to connect to broker "%s"' % broker_str)
         return(False)

      try:
         objs = self.session.getAgents()
         obj = []
         for agent in objs:
            if agent.label == 'com.redhat.grid.config:Store':
               obj = agent
               break
      except:
         obj = []

      if obj == []:
         log(logging.CRITICAL, self.logger_name, 'Failed to find configuration store agent')
         return(False)

      self.agent = obj

      try:
         obj = self.agent.getObjects(_class='Store', _package='com.redhat.grid.config')
      except:
         obj = []

      if obj == []:
         log(logging.CRITICAL, self.logger_name, 'Failed to contact configuration store')
         return(False)

      self.store = obj[0]

      # Check API version number
      if self.store.apiVersionNumber > 20100804:
         log(logging.CRITICAL, self.logger_name, 'The store is using a newer API version than is supported.  Exiting')
         return(False)

      result = self.store.getNode(self.node_name)
      if result.status != 0:
         log(logging.CRITICAL, self.logger_name, '(%d, %s): Store does not know about this node' % (result.status, result.text))
         return(False)
      else:
         try:
            obj = self.agent.getObjects(_objectId=result.outArgs['obj'])
         except:
            obj = []

         if obj == []:
            log(logging.CRITICAL, self.logger_name, 'Unable to get node information object')
            return(False)
         else:
            self.node_obj = obj[0]
            log(logging.DEBUG, self.logger_name, 'Retrieved node object from store')
      self.console.config(self.node_obj.name, self.logger_name)
      return(True)


   def setup_timers(self):
      # Setup the timer for checking configuration version
      if self.timer == None:
         if self.interval > 0:
            self.timer = Timer(self.interval, self.check_config_ver)
            self.timer.start()


   def shutdown(self):
      if self.timer != None:
         self.timer.stop()
         del self.timer
         self.timer = None
      if self.broker != None:
         self.session.delBroker(self.broker)
         self.broker = None


   def get_interval(self):
      return self.interval


   def check_config_ver(self, ver=0, force=False):
      log(logging.DEBUG, self.logger_name, 'Checking version of condor configuration')
      if self.node_obj == []:
         log(logging.ERROR, self.logger_name, 'No node object from the store')
         self.config_qmf_entities()
         return(False)

      self.lock.acquire(True)

      # If the passed version is 0, look at the last_updated_version
      if ver == 0:
         try:
            self.node_obj.update()
         except:
            # Agent/broker has gone away
            if self.config_qmf_entities() == False:
               self.lock.release()
               return(False)
         ver = int(self.node_obj.last_updated_version)

      # Install the new configuration (if needed)
      self.get_config(ver, force)

      # Check in with the store
      log(logging.DEBUG, self.logger_name, 'Performing a checkin with the store')
      try:
         self.node_obj.checkin()
      except Exception, error:
         log(logging.ERROR, self.logger_name, 'Failed to check in with the store')
         log(logging.ERROR, self.logger_name, error)
         self.lock.release()
         return(False)
      log(logging.DEBUG, self.logger_name, 'Checked in with the store')
      self.lock.release()
      return(True)


   def process_version_q(self):
      global version_queue

      version = -1
      try:
         version = version_queue.get(False)
      except Queue.Empty:
         return

      if version != -1:
         # There was a new version in the queue
         if self.check_config_ver(version) == False:
            if version_queue.empty() == True:
               # There hasn't been another version to look at, so put
               # this one back as there was an error installing it
               version_queue.put(version, False)


   def get_config(self, version=0, force=False):
      global replacing_file

      # Get the WALLABY_CONFIG_VERSION the master is running.  If the master is
      # running the same version as what we've received, then we know we don't
      # need do anything
      (retval, running_version, err) = run_cmd('condor_config_val WALLABY_CONFIG_VERSION')
      try:
         running_version = int(running_version.strip())
      except:
         running_version = 0
 
      if version == running_version and force == False:
         log(logging.DEBUG, self.logger_name, 'The system is already running configuration version "%d"' % version)
         return
      else:
         log(logging.INFO, self.logger_name, 'Retrieving configuration version "%d" from the store' % version)
   
         # Retrieve the node's configuration
         try:
            if version <= 0:
               result = self.node_obj.getConfig({})
            else:
               result = self.node_obj.getConfig({'version':version})
         except Exception, error:
            # Something has gone away, so fail silently
            log(logging.ERROR, self.logger_name, 'Exception when attempting to retrieve configuration version "%d" from the store' % version)
            log(logging.ERROR, self.logger_name, error)
            return
   
         if result.status != 0:
            # Problem getting the configuration, so do nothing
            log(logging.ERROR, self.logger_name, 'Failed to retrieve configuration "%d" from the store (%d, %s)' % (version, result.status, result.text))
            return
         else:
            config = result.outArgs['config']
   
         try:
            (file_hdl,file_name) = tempfile.mkstemp('.tmp', 'condor_config.local', text=True)
            # Write the config from the store into the file
            for key in config.keys():
               if key.strip().lower() == 'dc_daemon_list':
                  os.write(file_hdl, '%s =+ %s\n' % (key, config[key]))
               else:
                  os.write(file_hdl, '%s = %s\n' % (key, config[key]))

            # Now append the configuration from the configd configuration
            # file
            try:
               dir = read_condor_config('LOCAL_CONFIG', ['DIR'])['dir']
            except:
               log(logging.ERROR, self.logger_name, 'Failed to find the configd configuration.  Not writing configuration file')
               os.close(file_hdl)
               os.remove(file_name)
               return
            
            cfg_name = os.path.normpath('%s/99configd.config' % dir)
            cfg_file = open(cfg_name, 'r')
            for line in cfg_file:
               os.write(file_hdl, line)
            cfg_file.close()

            # Lastly, set LOCAL_CONFIG_DIR so it can't be overriden and close
            # the file handle
            os.write(file_hdl, 'LOCAL_CONFIG_DIR =')
            os.close(file_hdl)
         except IOError:
            log(logging.ERROR, self.logger_name, 'Failed to read configd configuration.  Not writing configuration file')
            return
         except:
            log(logging.ERROR, self.logger_name, 'Failed to write configuration to temp file')
            return
   
         # Verify the config file is valid
         (retval, out, err) = run_cmd('condor_config_val -dump', environ={'CONDOR_CONFIG':'%s' % file_name})
         if retval != 0:
            log(logging.ERROR, self.logger_name, 'Configuration is invalid.  Discarding')
            os.remove(file_name)
            return
   
         # Install the file for condor to use
         replacing_file = True
         if os.path.exists(self.managedfile):
            os.remove(self.managedfile)
         try:
            shutil.move(file_name, self.managedfile)
         except:
            log(logging.ERROR, self.logger_name, 'Error installing new configuration file')
            os.remove(file_name)
            replacing_file = False
            return
         os.chmod(self.managedfile, stat.S_IRUSR|stat.S_IWUSR|stat.S_IRGRP|stat.S_IWGRP|stat.S_IROTH)
         replacing_file = False
         log(logging.DEBUG, self.logger_name, 'Retrieved configuration from the store')
   
         # Have the store tell us which subsystems to restart/reconfig
         result = self.node_obj.whatChanged(running_version, version)
         if result.status != 0:
            log(logging.ERROR, self.logger_name, 'Store error: %d, %s' % (result.status, result.text))
            log(logging.ERROR, self.logger_name, 'Failed to retrive differences between versions "%d" and "%d".  No update performed' % (running_version, version))
            return
         else:
            restart_list = result.outArgs['restart']
            reconfig_list = result.outArgs['affected']

         log(logging.DEBUG, self.logger_name, 'Daemons to restart: %s' % restart_list)
         log(logging.DEBUG, self.logger_name, 'Daemons to reconfig: %s' % reconfig_list)

         # Determine the list of daemons the master is running, and only send
         # events to these daemons.  Any new daemons that should be running (or
         # any daemons that should be stopped) will be handled by commands sent
         # to the master
         (retval, daemons, err) = run_cmd('condor_config_val -master DAEMON_LIST')
         daemon_list = []
         if daemons != None:
            for daemon in daemons.split(','):
               daemon = daemon.strip()
               if daemon != '':
                  daemon_list += [daemon.lower()]
   
         # Process the subsystem lists and act upon them.  Start by processing
         # the daemons to restart, and if master is listed then don't process
         # anything else because restarting the master will take care of
         # everything
         cmd = 'condor_restart'
         if 'master' in restart_list:
            self.send_condor_command(cmd, 'master')
         else:
            self.act_upon_subsys_list(cmd, restart_list, daemon_list)
   
            # Now process the reconfig list.  Again, if master is listed then
            # don't do anything else as sending a reconfig event to the master
            # will handle everything 
            cmd = 'condor_reconfig'
            if 'master' in reconfig_list:
               self.send_condor_command(cmd, 'master')
            else:
               self.act_upon_subsys_list(cmd, reconfig_list, daemon_list)
   
   
   def act_upon_subsys_list(self, command, list, running_daemons):
      nondc_daemons = ['ll_daemon', 'configd']

      if list == []:
         return

      for subsys in list:
         subsys = str(subsys.strip())
         if subsys.lower() not in running_daemons:
            log(logging.DEBUG, self.logger_name, 'Not sending "%s" to subsystem "%s" since it is not currently running' % (command, subsys))
         else:
            if subsys.lower() in nondc_daemons:
               if self.send_condor_command('condor_off', subsys) == True:
                  self.send_condor_command('condor_on', subsys)
            else:
               self.send_condor_command(command, subsys)


   def send_condor_command(self, command, subsystem):
      log(logging.DEBUG, self.logger_name, 'Sending command "%s" to subsystem "%s"' % (command, subsystem))
      (retval, out, err) = run_cmd('%s -subsystem %s' % (command, subsystem))
      if retval != 0:
         log(logging.ERROR, self.logger_name, 'Failed to send command "%s" to subsystem "%s" (retval: %d, stdout: "%s", stderr: "%s")' % (command, subsystem, retval, out, err))
         return False
      else:
         log(logging.DEBUG, self.logger_name, 'Sent command "%s" to subsystem "%s"' % (command, subsystem))
         return True


def exit_signal_handler(signum, frame):
   global service, stop_running

   if service != None:
      service.shutdown()
      del service
      service = None
   logging.shutdown()
   stop_running = True

def test_for_shutdown():
	global pidfile

	if os.path.isfile(pidfile):
		os.remove(pidfile)
		exit_signal_handler(signal.SIGTERM, None)

version_queue = Queue.Queue()
service = Service()
stop_running = False
replacing_file = False
pidfile = os.path.normpath(os.getcwd() + '/.pid' + str(os.getpid()))

def main(argv=None):
   global service, stop_running, replacing_file

   if argv is None:
      argv = sys.argv

   try:
      file = {}
      retrieve = False
      logger_name = os.path.basename(argv[0])
      node_name = socket.gethostname()
      config_file = ''
      username = ''
      passwd = ''
      log_level = logging.INFO

      long_opts = ['debug', 'hostname=', 'logfile=', 'managedfile=', 
                   'password=', 'retrieve', 'user=']
      try:
         opts, args = getopt.gnu_getopt(argv[1:], 'dh:l:m:rP:U:', long_opts)
      except getopt.GetoptError, error:
         print str(error)
         return(1)

      for option, arg in opts:
         if option in ('-d', '--debug'):
            log_level = logging.DEBUG
         if option in ('-h', '--hostname'):
            node_name = arg
         if option in ('-l', '--logfile'):
            file['log'] = arg
         if option in ('-m', '--managedfile'):
            config_file = arg
         if option in ('-P', '--password'):
            passwd = arg
         if option in ('-r', '--retrieve'):
            retrieve = True
         if option in ('-U', '--user'):
            username = arg


      # Configure the logging system
      if 'log' not in file.keys():
         try:
            file = read_condor_config('QMF_CONFIGD', ['LOG'])
         except ConfigError, error:
            print 'Error: %s.  Exiting' % error.msg
            return(1)

      try:
         size = int(read_condor_config('MAX_QMF_CONFIGD', ['LOG'])['log'])
      except:
         size = 1000000

      # Set signal handlers
      signal.signal(signal.SIGINT, exit_signal_handler)
      signal.signal(signal.SIGTERM, exit_signal_handler)
      signal.signal(signal.SIGABRT, exit_signal_handler)
      signal.signal(signal.SIGILL, exit_signal_handler)
      signal.signal(signal.SIGFPE, exit_signal_handler)
      signal.signal(signal.SIGSEGV, exit_signal_handler)
      if os.name != 'nt' and os.name != 'ce':
         # These aren't available on windows
         signal.signal(signal.SIGQUIT, exit_signal_handler)

         # Run as the user condor if running as root
         if os.geteuid() == 0:
            # Get the uid and gid for the condor user
            pw_data = pwd.getpwnam('condor')
            os.setregid(pw_data[3], pw_data[3])
            os.setreuid(pw_data[2], pw_data[2])

      # Create the log file
      try:
         base_logger = create_file_logger(logger_name, file['log'], log_level, size=size)
      except:
         print 'Failed to open log file.  Exiting'
         return(1)

      log(logging.INFO, logger_name, 'Starting Up')

      # Retrieve the broker information from condor's configuration file
      if service != None:
         service.init(node_name, logger_name)
      if service != None and service.config(config_file, username, passwd) != True:
         if retrieve == True:
            print 'Error: Unable to retrieve configuration'
            log(logging.CRITICAL, logger_name, 'Unable to retrieve configuration')
         exit_signal_handler(0, 0)
         return(1)
      elif retrieve == True:
         if service != None:
            service.check_config_ver(force=True)
         exit_signal_handler(0, 0)
         return(0)

      # Delay initial checkin after startup 
      random.seed()
      time.sleep(random.randint(0, 10))
      if service != None:
         service.check_config_ver()
      if service != None:
         service.setup_timers()

      if os.name == 'nt' or os.name == 'ce':
         # need to set a Timer for shutdown
         log(logging.INFO, logger_name, 'Setting windows shutdown Timer')
         shutdown_interval = int(read_condor_config('QMF_CONFIGD', ['WIN_INTERVAL'])['win_interval'])
         shutdown_timer = Timer(shutdown_interval,test_for_shutdown)
         shutdown_timer.start()

      # Loop forever until told to shutdown
      while stop_running == False or replacing_file == True:
         try:
            time.sleep(1)
            service.process_version_q()
         except:
            pass
   except KeyboardInterrupt:
      pass

if __name__ == '__main__':
    sys.exit(main())
