#!/usr/bin/python
#   Copyright 2008 Red Hat, Inc.
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

import getopt
import os
import sys
import signal
from wallabyclient import WallabyHelpers
from qmf.console import Session


def exit_signal_handler(signum, frame):
   sys.exit(0)


def print_help(name):
   print 'usage: %s [-h|--help] [-b|--broker <broker>] [-o|--port <port>] [--load-snapshot|--remove-snapshot|--take-snapshot <snapshot>] [--schedds] [--qmfbroker] [-g|--group|-n|--node name] action [-f|--features feature[,feature,...]] [-p|--params param1,param2,...]' % os.path.basename(name)
   print '  <broker>    - The ip/hostname of the broker used by the configuration store'
   print '  <port>      - The port of the broker used by the configuration store'
   print '  <snapshot>  - The name of the snapshot'
   print '  --schedds   - Prompt for scheduler information when configuring'
   print '  --qmfbroker - Prompt for QMF broker information when configuring'
   print '  -h - Print help'
   print '\naction:'
   print '  -a|--add             - Add to the group/node'
   print '  -d|--delete          - Remove from the group/node'
   print '  -l|--list            - List the specific node/group/feature/param'
   print '                         configuration'
   print '  --activate           - Attempt to activate the configuration in'
   print '                         the store'
   print '  --list-all-features  - List all features in the store'
   print '  --list-all-groups    - List all groups in the store'
   print '  --list-all-nodes     - List all nodes in the store'
   print '  --list-all-params    - List all params in the store'
   print '  --list-all-snapshots - List all snapshots in the store'
   print '  --default-group      - Perform actions on the Default Group in'
   print '                         the store'


def configure_node_schedulers(params, is_delete):
   if is_delete == True:
      params['SCHEDD_NAME'] = ''
      params['SCHEDD_HOST'] = ''
   else: 
      def_sched = raw_input('Enter the name of the default scheduler: ')
      if def_sched != '':
         if raw_input('Is this a High Available Scheduler [y/N] ? ').lower() == 'y':
            params['SCHEDD_NAME'] = def_sched.strip()
         else:
            params['SCHEDD_HOST'] = def_sched.strip()


def configure_qmf_broker(params, is_delete):
   if is_delete == True:
      params['QMF_BROKER_HOST'] = ''
      params['QMF_BROKER_PORT'] = ''
   else:
      value = raw_input('Enter the hostname of the AMQP broker this group will use to communicate with the Management Console: ')
      if value != '':
         params['QMF_BROKER_HOST'] = value.strip()
      else:
         params['QMF_BROKER_HOST'] = value

      valid = False
      while valid == False:
         valid = True
         value = raw_input('Enter the port the AMQP broker listens on: ')
         if value != '':
            try:
               junk = int(value)
               params['QMF_BROKER_PORT'] = value.strip()
            except ValueError:
               print 'Error: "%s" is not a valid value' % value
               valid = False


def get_ec2e_routes():
   config = '$(JOB_ROUTER_ENTRIES)'
   answer = raw_input('Enable EC2 routing to the Small AMI type [y/N] ? ')
   if answer.lower() == 'y':
      config += ' [ GridResource = "condor localhost $(COLLECTOR_HOST)";'
      config += ' Name = "Amazon Small";'
      config += ' requirements=target.WantAWS is true && (target.Universe is vanilla || target.Universe is 5) && (target.WantArch is "INTEL" || target.WantArch is UNDEFINED) && (target.WantCpus <= 1 || target.WantCpus is UNDEFINED) && (target.WantMemory < 1.7 || target.WantMemory is UNDEFINED) && (target.WantDisk < 160 || target.WantDisk is UNDEFINED);'
      config += ' set_gridresource = "amazon";'
      config += ' set_amazoninstancetype = "m1.small";'
      config += ' set_remote_jobuniverse = 5;'
      config += get_aws_data()
      config += ' ]'

   answer = raw_input('Enable EC2 routing to the High-Compute Medium AMI type [y/N] ? ')
   if answer.lower() == 'y':
      config += ' [ GridResource = "condor localhost $(COLLECTOR_HOST)";'
      config += ' Name = "Amazon High-CPU Medium";'
      config += ' requirements=target.WantAWS is true && (target.Universe is vanilla || target.Universe is 5) && (target.WantArch is "INTEL" || target.WantArch is UNDEFINED) && ((target.WantCpus > 1 && target.WantCpus <= 5) || (target.WantDisk > 160 && target.WantDisk <= 350));'
      config += ' set_gridresource = "amazon";'
      config += ' set_amazoninstancetype = "c1.medium";'
      config += ' set_remote_jobuniverse = 5;'
      config += get_aws_data()
      config += ' ]'

   answer = raw_input('Enable EC2 routing to the High-Compute Extra Large AMI type [y/N] ? ')
   if answer.lower() == 'y':
      config += ' [ GridResource = "condor localhost $(COLLECTOR_HOST)";'
      config += ' Name = "Amazon High-CPU Extra Large";'
      config += ' requirements=target.WantAWS is true && (target.Universe is vanilla || target.Universe is 5) && target.WantArch is "X86_64" && target.WantCpus > 8 && target.WantCpus <= 20 && (target.WantMemory <= 7 || target.WantMemory is UNDEFINED) && (target.WantDisk <= 1690 || target.WantDisk is UNDEFINED);'
      config += ' set_gridresource = "amazon";'
      config += ' set_amazoninstancetype = "c1.xlarge";'
      config += ' set_remote_jobuniverse = 5;'
      config += get_aws_data()
      config += ' ]'

   answer = raw_input('Enable EC2 routing to the XLarge AMI type [y/N] ? ')
   if answer.lower() == 'y':
      config += ' [ GridResource = "condor localhost $(COLLECTOR_HOST)";'
      config += ' Name = "Amazon XLarge";'
      config += ' requirements=target.WantAWS is true && (target.Universe is vanilla || target.Universe is 5) && target.WantArch is "X86_64" && ((target.WantMemory > 7.5 && target.WantMemory <= 15) || (target.WantDisk > 850 && target.WantDisk < 1690) || (target.WantCpus > 4 && target.WantCpus <= 8));'
      config += ' set_gridresource = "amazon";'
      config += ' set_amazoninstancetype = "m1.xlarge";'
      config += ' set_remote_jobuniverse = 5;'
      config += get_aws_data()
      config += ' ]'

   answer = raw_input('Enable EC2 routing to the Large AMI type [y/N] ? ')
   if answer.lower() == 'y':
      config += ' [ GridResource = "condor localhost $(COLLECTOR_HOST)";'
      config += ' Name = "Amazon Large";'
      config += ' requirements=target.WantAWS is true && (target.Universe is vanilla || target.Universe is 5) && target.WantArch is "X86_64" && (target.WantCpus <= 4 || target.WantCpus is UNDEFINED) && (target.WantMemory <= 7.5 || target.WantMemory is UNDEFINED) && (target.WantDisk <= 850 || target.WantDisk is UNDEFINED);'
      config += ' set_gridresource = "amazon";'
      config += ' set_amazoninstancetype = "m1.large";'
      config += ' set_remote_jobuniverse = 5;'
      config += get_aws_data()
      config += ' ]'
   return (config, config == '$(JOB_ROUTER_ENTRIES)')


def get_aws_data():
   info = ''
   resp = raw_input('Enter a filename containing an AWS Public Key for this route: ')
   if resp.strip() != '':
      info += ' set_amazonpublickey = "%s";' % resp.strip()
   resp = raw_input('Enter a filename containing an AWS Private Key for this route: ')
   if resp.strip() != '':
      info += ' set_amazonprivatekey = "%s";' % resp.strip()
   resp = raw_input('Enter a filename containing an AWS Access Key for this route: ')
   if resp.strip() != '':
      info += ' set_amazonaccesskey = "%s";' % resp.strip()
   resp = raw_input('Enter a filename containing an AWS Secret Key for this route: ')
   if resp.strip() != '':
      info += ' set_amazonsecretkey = "%s";' % resp.strip()
   resp = raw_input('Enter a filename containing an RSA Public Key for this route: ')
   if resp.strip() != '':
      info += ' set_rsapublickey = "%s";' % resp.strip()
   resp = raw_input('Enter an S3 Storage Bucket name for this route: ')
   info += ' set_amazons3bucketname = "%s";' % resp.strip()
   resp = raw_input('Enter an SQS Queue name for this route: ')
   info += ' set_amazonsqsqueuename = "%s";' % resp.strip()
   resp = raw_input('Enter an AMI ID for use with this route: ')
   info += ' set_amazonamiid = "%s";' % resp.strip()
   return info


def get_feature_params(sess, store, feature):
   params = {}

   if feature != '':
      obj = WallabyHelpers.get_feature(sess, store, feature)
      if obj != None:
         result = obj.getParams()
         if result.status != 0:
            print 'Error: Unable to retrieve parameters for feature "%s" (%d, %s)' % (feature, result.status, result.text)
         else:
            params = result.outArgs['params']
   return params


def get_unique_mustchange_params(sess, store, feature_list, group_obj):
   param_list = {}
   feature_params = {}
   configed_feats = {}
   candidate_params = []
   mustchange_list = {}
   unique_params = {}

   # Get the list of parameters that must change from the store
   result = store.getMustChangeParams()
   if result.status != 0:
      print 'Error: Failed to retrieve list of MustChange parameters from the Configuration Store'
   else:
      mustchange_list = result.outArgs['params']
   
   # Iterate over the list of features and check each parameter included
   for feat in feature_list:
      feat_params = get_feature_params(sess, store, feat)

      # For each list of parameters, check to see if the MustChange is
      # true.
      if feat_params != {}:
         for param in feat_params.keys():
            # check if the parameter must be changed by the user and if so
            # see if it's value is the same as the parameter's default.  If
            # it is, that means the parameter hasn't been set
            if param in mustchange_list.keys() and \
               feat_params[param] == mustchange_list[param]:
               candidate_params += [param]

   # Now, get the parameter list for the features configured on
   # the group
   result = group_obj.getFeatures()
   if result.status != 0:
      print 'Error: Failed to retrieve features configured (%d, %s)' % (result.status, result.text)
   else:
      configed_feats = result.outArgs['features']

   # Generate the list of parameters for these features
   for feat in configed_feats:
      obj = WallabyHelpers.get_feature(sess, store, feat)
      if obj != None:
         result = obj.getParams()
         if result.status != 0:
            print 'Error: Unable to retrieve parameters for configured feature "%s" (%d, %s)' % (feat, result.status, result.text)
            continue
         else:
            feature_params.update(result.outArgs['params'])

   # Now, determine if any of the candidate parameters aren't set for
   # any of the configured features.  If they aren't, add them to
   # the list of unique must set parameters
   for param in candidate_params:
      if param not in feature_params.keys() or \
         feature_params[param] == mustchange_list[param]:
         unique_params[param] = False

   return unique_params


def set_param(name, value, param_list, unique_list = None):
   param_list[name] = value
   if unique_list != None:
      try:
         del unique_list[name]
      except:
         pass

def check_more_params_needed(sess, store, features, params, more_params, gobj):
   list = {}

   # Get a list of unique must set parameters for the features being added
   unique_params = get_unique_mustchange_params(sess, store, features, gobj)

   # Get the list of parameters for the group
   result = gobj.getConfig()
   if result.status != 0:
      print 'Error: Unable to determine if special configuration is needed'
   else:
      list = result.outArgs['config']

   # Check for special case parameters

   # Check for EC2 Enhanced
   if ('NEED_SET_EC2E_ROUTES' in list.keys() and \
      list['NEED_SET_EC2E_ROUTES'].lower() == 'true') or \
      'EC2Enhanced' in features or \
      ('NEED_SET_EC2E_ROUTES' in params.keys() and \
      params['NEED_SET_EC2E_ROUTES'].lower() == 'true'):

      (routes, empty_routes) = get_ec2e_routes()
      set_param('JOB_ROUTER_ENTRIES', routes, params, unique_params)
      if empty_routes == False:
         set_param('NEED_SET_EC2E_ROUTES', 'FALSE', params, unique_params)
      else:
         set_param('NEED_SET_EC2E_ROUTES', 'TRUE', params, unique_params)

   # Check for VM Universe parameters
   vm_remove_params = {}
   if 'VMUniverse' in features:
      input = ''
      while input != 'xen' and input != 'kvm':
         input = raw_input('Type of Virtual Machines to run on this node (xen or kvm): ')
         if input != '':
            input = input.lower().strip()
         if input != 'xen' and input != 'kvm':
            print 'Error: "%s" is not a valid Virtual Machine type.  Please try again' % input
      
      set_param('VM_TYPE', input, params, unique_params)
      if input == 'xen':
         set_param('XEN_BOOTLOADER', '/usr/bin/pygrub', params, unique_params)
      else:
         vm_remove_params['XEN_BOOTLOADER'] = False
   if 'VMUniverse' in features:
      input = raw_input('Enable networking in the VM universe [y/N] ? ')
      if input.lower() == 'y':
         set_param('VM_NETWORKING', 'TRUE', params, unique_params)
         type = ''
         while type.strip().lower() != 'both' and \
               type.strip().lower() != 'nat' and \
               type.strip().lower() != 'bridge':
            type = raw_input('Supported VM networking type (nat, bridge, both): ')
            if type.strip() == 'both':
               set_param('VM_NETWORKING_TYPE', 'nat, bridge', params, unique_params)
               input = ''
               while input.strip().lower() != 'nat' and \
                     input.strip().lower() != 'bridge':
                  input = raw_input('Default VM networking type (nat or bridge): ')
                  if input.strip().lower() != 'nat' and \
                     input.strip().lower() != 'bridge':
                     print '"%s" is an invalid default VM networking type.  Please try again' % input
               set_param('VM_NETWORKING_DEFAULT_TYPE', input.strip(), params, unique_params)
            elif type.strip().lower() == 'nat' or type.strip().lower() == 'bridge':
               set_param('VM_NETWORKING_TYPE', type.strip(), params, unique_params)
               vm_remove_params['VM_NETWORKING_DEFAULT_TYPE'] = False
            else:
               print 'Invalid input "%s"' % type
      else:
         set_param('VM_NETWORKING', 'FALSE', params, unique_params)
         vm_remove_params['VM_NETWORKING_DEFAULT_TYPE'] = False
         vm_remove_params['VM_NETWORKING_TYPE'] = False

      if vm_remove_params != {}:
         result = gobj.getParams()
         if result.status != 0:
            print 'WARNING: Unable to retrieve group set parameters (%d, %s)' % (result.status, result.text)
            gparams = {}
         else:
            gparams = result.outArgs['params']
        
         for remove_param in vm_remove_params.keys():
            if remove_param in gparams.keys():
               del gparams[remove_param]
         result = gobj.modifyParams('replace', gparams, {})
         if result.status != 0:
            print 'WARNING: Unable to remove VM Universe Networking parameters (%d, %s)' % (result.status, result.text)

   # Prompt the user if there are still parameters that need to be set
   if len(unique_params) > 0:
      print 'The following parameters need to be set for this configuration to be valid.'
      for param in sorted(unique_params.keys()):
         if param != '' and param not in params.keys() and \
            param not in more_params.keys():
            print param
      answer = raw_input('Set these parameters now ? [y/N] ')
      if answer.lower() == 'y':
         for param in sorted(unique_params.keys()):
            if param != '' and param not in params.keys() and \
               param not in more_params.keys():
               value = raw_input('%s: '% param)
               set_param(param, value.strip(), params)
      else:
         print 'Electing not to set these parameters now'
         print 'WARNING: This configuration may not be able to be activated'


def check_delete_params_needed(sess, store, features, params, gobj):
   # Grab the list of unique must set parameters for each feature being removed
   unique_params = get_unique_mustchange_params(sess, store, features, gobj)

   # Update the list of parameters to include the unique parameters that
   # must be set by the user
   params.update(unique_params)

   # Special cases
   for feat in features:
      feat_params = get_feature_params(sess, store, feat)
      if 'NEED_SET_EC2E_ROUTES' in feat_params.keys():
         # In case this was set
         params['NEED_SET_EC2E_ROUTES'] = False
      if 'VM_TYPE' in feat_params.keys():
         # Remove all the VM Universe params that are always set
         params['VM_TYPE'] = False
         params['XEN_BOOTLOADER'] = False
         params['VM_NETWORKING'] = False
         params['VM_NETWORKING_TYPE'] = False
         params['VM_NETWORKING_DEFAULT_TYPE'] = False


def activate_configuration(store):
   ret_val = False
   result = store.activateConfiguration()
   if result.status != 0:
      print 'Error: Unable to active changes (%d, %s)' % (result.status, result.text)
   else:
      errors = result.outArgs['explain']
      warnings = result.outArgs['warnings']
      if warnings != []:
         for warn in warnings:
            print 'Warning: %s' % warn
         print
      if errors != {}:
         print 'The configuration is not valid'
         for node in sorted(errors.keys()):
            if node == '+++DEFAULT':
               print 'Node: Internal Default Group'
            else:
               print 'Node: %s' % node
            for reason in errors[node].keys():
               print '%s:' % reason
               for param in sorted(errors[node][reason]):
                  print '  %s' % param
            print
         print 'Configuration not activated'
      else:
         ret_val = True
         print 'Configuration activated'
   return ret_val


def save_snapshot(store, name):
   result = store.makeSnapshot(name)
   if result.status != 0:
      print 'Error: Problem saving configuration in store (%d, %s)' % (result.status, result.text)
   else: 
      print 'Configuration saved'


def main(argv=None):
   if argv is None:
      argv = sys.argv

   action = ''
   features = ''
   params = ''
   broker_ip = '127.0.0.1'
   name = ''
   node = ''
   port = 5672
   param_list = {}
   replace_list = {}
   group_config = {}
   config_store = []
   session = []
   list_alls = []
   broker_prompts = False
   schedd_prompts = False
   feature_list = []
   group_obj = []
   username = ''
   passwd = ''

   # Set signal handlers
   signal.signal(signal.SIGINT, exit_signal_handler)
   signal.signal(signal.SIGTERM, exit_signal_handler)

   long_opts = ['activate', 'add', 'broker=', 'default-group', 'delete',
                'features=', 'group=', 'help', 'list', 'list-all-features',
                'list-all-groups', 'list-all-nodes', 'list-all-params',
                'list-all-snapshots', 'load-snapshot=', 'node=', 'params=',
                'password=', 'port=', 'qmfbroker', 'remove-snapshot=',
                'schedds', 'take-snapshot=', 'user=']

   try:
      opts, args = getopt.gnu_getopt(argv[1:], 'ab:df:g:hln:p:P:o:U:', long_opts)
   except getopt.GetoptError, error:
      print str(error)
      return(1)

   for option, arg in opts:
      if option == '--activate':
         if action != '':
            print 'Only 1 action may be specified'
            return(1)
         action = 'activate'
      if option in ('-a', '--add'):
         if action != '':
            print 'Only 1 action may be specified'
            return(1)
         action = 'add'
      if option in ('-b', '--broker'):
         broker_ip = arg
      if option == '--default-group':
         if name != '' or node != '':
            print 'Can only configure 1 node or group at a time'
         name = '+++DEFAULT'
      if option in ('-d', '--delete'):
         if action != '':
            print 'Only 1 action may be specified'
            return(1)
         action = 'remove'
      if option in ('-f', '--features'):
         features = arg
      if option in ('-g', '--group'):
         if name != '' or node != '':
            print 'Can only configure 1 node or group at a time'
            return(1)
         name = arg
      if option in ('-h', '--help'):
         print_help(argv[0])
         return(0)
      if option in ('-l', '--list'):
         if action != '':
            print 'Only 1 action may be specified'
            return(1)
         action = 'list'
      if option in ('--list-all-features', '--list-all-groups',
                    '--list-all-nodes', '--list-all-params',
                    '--list-all-snapshots'):
         if action != '' and action != 'list-all':
            print 'Only 1 action may be specified'
            return(1)
         action = 'list-all'
         if option == '--list-all-features':
            list_alls += ['Feature']
         elif option == '--list-all-groups':
            list_alls += ['Group']
         elif option == '--list-all-nodes':
            list_alls += ['Node']
         elif option == '--list-all-params':
            list_alls += ['Parameter']
         elif option == '--list-all-snapshots':
            list_alls += ['Snapshot']
      if option  == '--load-snapshot':
         if action != '':
            print 'Only 1 action may be specified'
            return(1)
         action = 'load-snapshot'
         snapshot_name = arg
      if option in ('-n', '--node'):
         if name != '' or node != '':
            print 'Can only configure 1 node or group at a time'
            return(1)
         node = arg
      if option in ('-o', '--port'):
         try:
            port = int(arg)
         except:
            print 'Invalid broker port'
            return(1)
      if option in ('-p', '--params'):
         params = arg
      if option in ('-P', '--password'):
         passwd = arg
      if option == '--qmfbroker':
         broker_prompts = True
      if option in ('--remove-snapshot'):
         if action != '':
            print 'Only 1 action may be specified'
            return(1)
         action = 'remove-snapshot'
         snapshot_name = arg
      if option == '--schedds':
         schedd_prompts = True
      if option  == '--take-snapshot':
         if action != '':
            print 'Only 1 action may be specified'
            return(1)
         action = 'take-snapshot'
         snapshot_name = arg
      if option in ('-U', '--user'):
         username = arg

   if action == '':
      print 'No action specified.  Exiting'
      print_help(argv[0])
      return(1)

   # Connect to the broker
   session = Session()
   try:
      if username != '' and passwd != '':
         broker = session.addBroker('amqp://%s/%s@%s:%d' % (username, passwd, broker_ip, port))
      elif username != '':
         broker = session.addBroker('amqp://%s@%s:%d' % (username, broker_ip, port))
      else:
         broker = session.addBroker('amqp://%s:%d' % (broker_ip, port))
   except:
      print 'Unable to connect to broker "%s:%d"' % (broker_ip, port)
      return(1)

   # Retreive the config store object
   try:
      config_store = session.getObjects(_class='Store', _package='mrg.grid.config')
   except Exception, error:
      print 'Error: %s' % error
      return(1)

   if config_store == []:
      print 'Unable to contact Configuration Store'
   else:
      config_store = config_store[0]
       
   if config_store == []:
      return(1)

   # Attempt to activate the configuration in the store if told to do so
   if action == 'activate':
      if activate_configuration(config_store) == False:
         return(1)
      else:
         return(0)

   # Process the list-alls, if there are any
   if action == 'list-all':
      for type in list_alls:
         try:
            objs = session.getObjects(_class=type, _package='mrg.grid.config')
         except Exception, error:
            print 'Error: %s' % error
            return(1)

         print '\n%ss:' % type
         if type == 'Feature' or type == 'Group':
            if objs == []:
               print '  There are no %ss in the store' % type
            else:
               for obj in objs:
                  result = obj.getName()
                  if result.status == 0:
                     name = result.outArgs['name']
                     if '+++' != name[0:3]:
                        print '  %s' % name
               if type == 'Group':
                  print '  Internal Default Group'
         if  type == 'Node' or type == 'Parameter' or type == 'Snapshot':
            if objs == []:
               print '  There are no %ss in the store' % type
            else:
               for obj in objs:
                  print '  %s' % obj.getIndex()
      return(0)

   # Process snapshots
   if action == 'load-snapshot':
      result = config_store.loadSnapshot(snapshot_name)
      if result.status != 0:
         print 'Error: Failed to load snapshot "%s" (%d %s)' % (snapshot_name, result.status, result.text)
         return(1)
      print 'Snapshot loaded'
      return(0)
   elif action == 'remove-snapshot':
      result = config_store.removeSnapshot(snapshot_name)
      if result.status != 0:
         print 'Error: Failed to remove snapshot "%s" (%d %s)' % (snapshot_name, result.status, result.text)
         return(1)
      print 'Snapshot removed'
      return(0)
   elif action == 'take-snapshot':
      save_snapshot(config_store, snapshot_name)
      return(0)

   # If configuring a single node, grab that node's identity group and
   # act upon that
   if node != '':
      obj = WallabyHelpers.get_node(session, config_store, node)
      if obj == None:
         return(1)
      else:
         name = WallabyHelpers.get_id_group_name(obj, session)
         if name == None:
            return(1)

   # Perform list opertions
   if action == 'list':
      if name != '':
         # Provide the configuration for the group/node
         if node != '':
            WallabyHelpers.list_node_info(session, config_store, node)
         else:
            WallabyHelpers.list_group_info(session, config_store, name)
      if features != '':
         # Provide the configuration for the features
         for feat in features.split(','):
            print 'Configuration for feature %s:' % feat
            WallabyHelpers.list_feature_info(session, config_store, feat)
      for param in params.split(','):
         WallabyHelpers.list_param_info(session, config_store, param)
            
      return(0)

   if name == '':
      print 'No name supplied.  Exiting'
      print_help(argv[0])
      return(1)
   elif features == '' and params == '' and schedd_prompts == False and \
        broker_prompts == False:
      print 'No targets specified.  Exiting'
      print_help(argv[0])
      return(1)
   else:
      # Query the store to get the group
      group_obj = WallabyHelpers.get_group(session, config_store, name)
      if group_obj == None:
         return(1)

      # Generate the list of features to act upon
      if features != '':
         feature_list = features.split(',')
         
      # Prompt for param values entered on the command line, if any
      for param in params.split(','):
         if param != '':
            if action == 'add':
               input = raw_input('Value for "%s": ' % param)
               if input != '':
                  param_list[param] = input.strip()
               else:
                  param_list[param] = input
            else:
               param_list[param] = False

      # Configure which schedulers the node can submit to
      if schedd_prompts == True:
         configure_node_schedulers(replace_list, action == 'remove')

      # Configure the AMQP broker used to communicate with the Management
      # Console
      if broker_prompts == True:
         configure_qmf_broker(replace_list, action == 'remove')

      if raw_input('\nApply these changes [Y/n] ? ').lower() != 'n':
         if feature_list != []:
            result = group_obj.modifyFeatures(action, feature_list, {})
            if result.status != 0:
               print 'Error: Problem modifying features (%d, %s)' % (result.status, result.text)
               return(1)

          # Check if any additional params need to be added/removed
         if action != 'remove':
            check_more_params_needed(session, config_store, feature_list, param_list, replace_list, group_obj)
         else:
            param_list.update(replace_list)
            replace_list = {}
            check_delete_params_needed(session, config_store, feature_list, param_list, group_obj)

         if param_list != {}:
            result = group_obj.modifyParams(action, param_list, {})
            if result.status != 0:
               print 'Error: Problem modifying parameters (%d, %s)' % (result.status, result.text)
               return(1)

         if replace_list != {}:
            result = group_obj.getParams()
            if result.status != 0:
               print 'Error: Problem retrieving parameters (%d, %s)' % (result.status, result.text)
               return(1)
            else:
               all_params = result.outArgs['params']
               all_params.update(replace_list)
               special = ['SCHEDD_NAME', 'SCHEDD_HOST']
               for sparam in special:
                  if sparam in all_params.keys() and \
                     sparam not in replace_list.keys():
                     try:
                        del all_params[sparam]
                     except:
                        pass
           
            result = group_obj.modifyParams('replace', all_params, {})
            if result.status != 0:
               print 'Error: Problem modifying parameters (%d, %s)' % (result.status, result.text)
               return(1)
         print 'Configuration applied'

         retry = True
         config_name = ''
         while retry == True:
            retry = False
            if raw_input('\nCreate a named snapshot of this configuration [y/N] ? ').lower() == 'y':
               config_name = raw_input('  Snapshot Name: ')
               if config_name == '':
                  retry = True
                  print 'Invalid configuration name'
                  continue 
               save_snapshot(config_store, config_name.strip())

         if raw_input('\nActivate the changes [y/N] ? ').lower() == 'y':
            if activate_configuration(config_store) == True and \
               config_name == '':
               save_snapshot(config_store, '')
         else: 
            print 'Configuration not activated'
      else:
         print 'Configuration not applied'
   session.delBroker(broker)

if __name__ == '__main__':
    sys.exit(main())
