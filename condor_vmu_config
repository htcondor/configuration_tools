#!/usr/bin/python
#   Copyright 2013 Red Hat, Inc.
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

import ConfigParser
import os
import shutil
import sys
import tempfile
import time
from condorutils.readconfig import run_cmd
from optparse import OptionParser

class VMUFeature:
  def __init__(self):
    self.type = "kvm"
    self.name = "CustomVMUniverse@%d" % int(time.time())
    self.include = "VMUniverse"
    self.outfile = None
    self.net = None
    self.net_type = None
    self.net_def = None
    self.bridge = None
    self.config = {}

  def init(self):
    for v in self.__dict__:
      if "VMU_%s" % v in os.environ.keys():
        setattr(self, v, os.environ["VMU_%s" % v])

  def parse_args(self):
    cargs = ["net", "net_type", "net_def", "bridge"]

    parser = OptionParser("usage: %prog [options] ARG=VALUE ...\n" + "Where ARG is one of %s" % ', '.join(map(str, cargs)))
    parser.add_option("-f", "--file", dest="infile", type="string", help="read feature data from INFILE.  If provided, arguments provided on the command line will be ignored", metavar="INFILE")
    parser.add_option("-o", "--outfile", dest="outfile", type="string", help="save configuration to OUTFILE", metavar="OUTFILE")
    parser.add_option("-n", "--name", dest="name", type="string", help="name of the feature")
    parser.add_option("-i", "--include", dest="include", type="string", help="name of the feature to include [default: %s]" % self.include)
    parser.add_option("-t", "--type", dest="type", choices=["kvm", "xen"], type="choice", help="type of VM to support [default: %s]" % self.type)

    (opts, args) = parser.parse_args()
    if opts.infile != None:
      # Read feature options from the file
      if os.path.exists(opts.infile) == False:
        raise RuntimeError("%s does not exist" % opts.infile)

      parser = ConfigParser.ConfigParser()
      parser.read(opts.infile)
      self.name = parser.sections().pop()
      for n, v in parser.items(self.name):
        if hasattr(self, n) == False:
          raise RuntimeError("%s is an invalid argument" % n)
        setattr(self, n, v)
    else:
      # Minimally need to provide networking option
      if len(args) < 1 and self.net == None:
        parser.print_help()
        raise RuntimeError("Incorrect number of arguments")
      else:
        for arg in args:
          (name, value) = arg.split('=', 1)
          if hasattr(self, name) == False:
            raise RuntimeError("%s is an invalid argument" % name)
          setattr(self, name, value)

    # Options on the command line trump everything
    for n, v in opts.__dict__.items():
      if v != None:
        setattr(self, n, v)

  def type_args(self):
    self.config["VM_TYPE"] = self.type
    if self.type == "xen":
      self.config["XEN_BOOTLOADER"] = "/usr/bin/pygrub"

  def net_args(self):
    self.config["VM_NETWORKING"] = str(self.net).upper()
    if self.net.lower() == "true":
      net_types = ["nat", "bridge", "both"]

      # Networking type
      if self.net_type == None:
        raise RuntimeError("Must provide a networking type if networking is enabled")
      if not self.net_type in net_types:
        raise RuntimeError("%s is an invalid networking type.  It must be one of %s" % (self.net_type, net_types))
      self.config["VM_NETWORKING_TYPE"] = self.net_type

      # Default networking
      if self.net_type.lower() == "both":
        def_types = ["nat", "bridge"]

        if self.net_def == None:
          raise RuntimeError("Must provide a networking default type if networking type is both")

        if not self.net_def in def_types:

          raise RuntimeError("%s is an invalid default networking type.  It must be one of %s" % (self.net_def, def_types))
        self.config["VM_NETWORKING_DEFAULT_TYPE"] = self.net_def

      # Bridge interface
      if self.net_type.lower() != "nat":
        if self.bridge == None:
          raise RuntimeError("Must provide a bridge network adapter if bridged networking is to be used")
        self.config["VM_NETWORKING_BRIDGE_INTERFACE"] = self.bridge

  def write_to_file(self):
    (hdl, fn) = tempfile.mkstemp(".tmp", self.name, text=True)
    os.write(hdl, "#name %s\n" % self.name)
    os.write(hdl, "#includes %s\n" % self.include)
    for key in self.config.keys():
      os.write(hdl, "%s = %s\n" % (key, self.config[key]))
    os.close(hdl)
    return(fn)

  def add_to_store(self, fname):
    (ret, out, err) = run_cmd("wallaby feature-import %s" % fname)
    if ret != 0:
      if out != "":
        print out
      if err != "":
        print err
      raise RuntimeError("There was a problem adding the feature to the store")

  def create(self):
    self.init()
    self.parse_args()
    self.type_args()
    self.net_args()
    f = self.write_to_file()
    self.add_to_store(f)
    if self.outfile != None:
      shutil.move(f, self.outfile)
    else:
      os.unlink(f)

if __name__ == '__main__':
  try:
    sys.exit(VMUFeature().create())
  except Exception, e:
    print e
    sys.exit(1)
