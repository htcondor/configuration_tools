#!/usr/bin/python
#   Copyright 2008 Red Hat, Inc.
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

import os
import sys
import logging
import signal
import time
import socket
import threading
import getopt
import random
import tempfile
import shutil
from qmf.console import Session, Console
from condorutils.log import *
from condorutils.readconfig import *


class Timer (threading.Thread):
   def __init__ (self, interval, function, args=[], kwargs={}):
      threading.Thread.__init__(self)
      self.interval = interval
      self.function = function
      self.args = args
      self.kwargs = kwargs
      self.setDaemon(True)
      self.finished = threading.Event()


   def stop (self):
      self.finished.set()
      self.join()


   def run (self):
      while not self.finished.isSet():
         self.finished.wait(self.interval)
         self.function(*self.args, **self.kwargs)


class EventConsole(Console):
   def __init__(self):
      self.node = []
      self.logger_name = ''
      self.name = ''


   def config(self, obj, name):
      self.node = obj
      self.logger_name = name


   def event(self, broker, event):
      if event.getClassKey().getClassName() == 'RestartEvent':
         args = event.getArguments()
         affected_hosts = args['AffectedNodes'].split(',')
         if self.node.getIndex() in affected_hosts:
            get_config(self.node, self.logger_name)
            if args['Restart'] == True:
               cmd = 'condor_restart'
            else:
               cmd = 'condor_reconfig'

            targets = args['Targets'].values()[0]
            for subsys in targets.split(','):
               if subsys == 'carod' or subsys == 'qmf_configd':
                  (retval, out, err) = run_cmd('condor_restart -subsystem %s' % subsys)
               else:
                  (retval, out, err) = run_cmd('%s -subsystem %s' % (cmd, subsys))
               if retval != 0:
                  log(logging.ERROR, self.logger_name, 'Failed to send command to subsystem "%s" (stdout: %s, stderr: %s)' % (subsys, out, err))
      elif event.getClassKey().getClassName() == 'NewConfigEvent':
#         print dir(event)
#         args = event.getArguments()
#         affected_hosts = args['nodelist']
#         if self.node.getIndex() in affected_hosts.keys():
         if True:
            get_config(self.node, self.logger_name)
            (retval, out, err) = run_cmd('condor_restart -subsystem master')
            if retval != 0:
               log(logging.ERROR, self.logger_name, 'Failed to send command to subsystem "master" (stdout: %s, stderr: %s)' % (out, err))


class Service:
   def __init__(self):
      self.broker_ip = ''
      self.broker_port = 5672
      self.broker = None
      self.console = None
      self.session = None
      self.store = []
      self.interval = 0
      self.node_obj = []
      self.logger_name = ''
      self.timer = None


   def init(self, name):
      self.console = EventConsole()
      self.session = Session(self.console, manageConnections=False, rcvObjects=False, rcvHeartbeats=False, rcvEvents=True)
      self.logger_name = name


   def config(self):
      if self.broker != None:
         self.session.delBroker(self.broker)
         self.broker = None

      if self.store != []:
         self.store = []

      try:
         val = read_condor_config('QMF_BROKER', ['HOST'])
         self.broker_ip = val['host']
      except ConfigError, error:
         # Broker host not defined, so exit
         log(logging.ERROR, self.logger_name, '%s.  Exiting' % error.msg)
         return(False)

      try:
         val = read_condor_config('QMF_BROKER', ['PORT'])
         self.broker_port = val['port']
      except ConfigError, error:
         log(logging.INFO, self.logger_name, '%s. Using default (5672)' % error.msg)
         self.broker_port = 5672

      try:
         val = read_condor_config('QMF_CONFIGD', ['CHECK_INTERVAL'])
         self.interval = int(val['check_interval'])
      except ConfigError, error:
         log(logging.INFO, self.logger_name, '%s. Node configuration evaluation disabled' % error.msg)
         self.interval = 0
       
      try:
         self.broker = self.session.addBroker('amqp://%s:%s' % (self.broker_ip, self.broker_port))
      except:
         log(logging.CRITICAL, self.logger_name, 'Unable to connect to broker "%s"' % self.broker_ip)
         return(False)

      try:
         obj = self.session.getObjects(_class='Store', _package='mrg.grid.config')
      except:
         obj = []

      if obj == []:
         log(logging.CRITICAL, self.logger_name, 'Failed to contact configuration store.  Exiting')
         return(False)

      self.store = obj[0]
      result = self.store.getNode(socket.gethostname())
      if result.status != 0:
         log(logging.CRITICAL, self.logger_name, '(%d, %s): Store does not know about this node' % (result.status, result.text))
         return(False)
      else:
         try:
            obj = self.session.getObjects(_objectId=result.outArgs['obj'])
         except:
            obj = []

         if obj == []:
            log(logging.CRITICAL, self.logger_name, 'Unable to get node information object')
            return(False)
         else:
            self.node_obj = obj[0]
      self.console.config(self.node_obj, self.logger_name)

      return(True)


   def setup_timers(self):
      # Setup the timer for checking configuration version
      if self.timer == None:
         if self.interval > 0:
            self.timer = Timer(self.interval, self.check_config_ver)
            self.timer.start()


   def shutdown(self):
      if self.timer != None:
         self.timer.stop()
         del self.timer
         self.timer = None
      if self.broker != None:
         self.session.delBroker(self.broker)
         self.broker = None


   def get_interval(self):
      return self.interval


   def check_config_ver(self):
      log(logging.INFO, self.logger_name, 'Checking version of condor configuration')
      if self.node_obj == []:
         log(logging.ERROR, self.logger_name, 'No node object from the store')
         return(1)

      try:
         val = read_condor_config('WALLABY_CONFIG', ['VERSION'])
         version = int(val['version'])
      except ConfigError, error:
         # Never been configured before, so send a bank version
         version = -1
      if version != self.node_obj.last_updated_version:
         get_config(self.node_obj, self.logger_name)


def get_config(node_obj, log_name):
   global replacing_file

   # Retrieve the node's configuration
   result = node_obj.getConfig()
   if result.status != 0:
      # Problem getting the configuration, so do nothing
      log(logging.ERROR, log_name, 'Failed to retrieve configuration from the store (%d, %s)' % (result.status, result.text))
      return
   else:
      config = result.outArgs['config']

   (temp_file,name) = tempfile.mkstemp('.tmp', 'condor_config.local', text=True)
   for key in config.keys():
      os.write(temp_file, '%s = %s\n' % (key, config[key]))
   os.close(temp_file)

   # Verify the config file is valid
   (retval, out, err) = run_cmd('condor_config_val -dump', environ={'CONDOR_CONFIG':'%s' % name})
   if retval != 0:
      log(logging.ERROR, log_name, 'Configuration is invalid.  Discarding')
      os.remove(name)
      return

   # Install the file for condor to use
   try:
      loc = read_condor_config('LOCAL_CONFIG', ['DIR'])
   except:
      log(logging.ERROR, log_name, 'LOCAL_CONFIG_DIR not defined.  Unable to write config')
      return

   file_name = '%s/00wallaby_node.config' % loc['dir']
   replacing_file = True
   if os.path.exists(file_name):
      os.remove(file_name)
   shutil.move(name, file_name)
   replacing_file = False

   node_obj.checkin()


def exit_signal_handler(signum, frame):
   global service, stop_running

   service.shutdown()
   del service
   logging.shutdown()
   stop_running = True


service = Service()
stop_running = False
replacing_file = False

def main(argv=None):
   global service, stop_running, replacing_file

   try:
      size = {}

      if argv is None:
         argv = sys.argv

      long_opts = ['retrieve']

      # Configure the logging system
      try:
         file = read_condor_config('QMF_CONFIGD', ['LOG'])
      except ConfigError, error:
         print 'Error: %s.  Exiting' % error.msg
         return(1)

      try:
         size = int(read_condor_config('MAX_QMF_CONFIGD', ['LOG'])['log'])
      except:
         size = 1000000
         

      base_logger = create_file_logger(os.path.basename(argv[0]), file['log'], logging.INFO, size=size)

      try:
         opts, args = getopt.gnu_getopt(argv[1:], 'r', long_opts)
      except getopt.GetoptError, error:
         print str(error)
         return(1)

      for option, arg in opts:
         if option in ('-r', '--retrieve'):
            service.init(os.path.basename(argv[0]))
            if service.config() != True:
               print 'Error: Unable to retrieve configuration'
               return(1)
            else:
               service.check_config_ver()
               logging.shutdown()
               return(0)

      # Set signal handlers
      signal.signal(signal.SIGINT, exit_signal_handler)
      signal.signal(signal.SIGTERM, exit_signal_handler)

      # Retrieve the broker information from condor's configuration file
      service.init(os.path.basename(argv[0]))
      if service.config() != True:
         return(1)

      # Delay initial checkin after startup 
      random.seed()
      time.sleep(random.randint(0, 10))
      service.setup_timers()

      # Loop forever until told to shutdown
      while stop_running == False or replacing_file == True:
         try:
            time.sleep(1)
         except:
            pass
   except KeyboardInterrupt:
      pass

if __name__ == '__main__':
    sys.exit(main())
