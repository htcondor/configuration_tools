#!/usr/bin/python
#   Copyright 2008 Red Hat, Inc.
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

import os
import sys
import logging
import signal
import time
import socket
import threading
import getopt
import random
import tempfile
import shutil
from qmf.console import Session, Console
from condorutils.log import *
from condorutils.readconfig import *


class Timer (threading.Thread):
   def __init__ (self, interval, function, args=[], kwargs={}):
      threading.Thread.__init__(self)
      self.interval = interval
      self.function = function
      self.args = args
      self.kwargs = kwargs
      self.setDaemon(True)
      self.finished = threading.Event()


   def stop (self):
      self.finished.set()
      self.join()


   def run (self):
      while not self.finished.isSet():
         self.finished.wait(self.interval)
         if not self.finished.isSet():
            self.function(*self.args, **self.kwargs)


class EventConsole(Console):
   def __init__(self):
      self.node = []
      self.logger_name = ''
      self.managedfile = ''
      self.lock = None


   def config(self, obj, name, filename, lock_obj):
      self.node = obj
      self.logger_name = name
      self.managedfile = filename
      self.lock = lock_obj


   def event(self, broker, event):
      if event.getClassKey().getClassName() == 'WallabyConfigEvent':
         log(logging.INFO, self.logger_name, 'Received a WallabyConfigEvent')
         args = event.getArguments()
         affected_hosts = args['affectedNodes']
         if self.node.getIndex() in affected_hosts.keys():
            log(logging.INFO, self.logger_name, 'The event is for this node')
            get_config(self.node, self.lock, self.logger_name, self.managedfile, affected_hosts[self.node.getIndex()])
            if args['restart'] == True:
               cmd = 'condor_restart'
            else:
               cmd = 'condor_reconfig'

            targets = args['targets']
            for subsys in targets:
               subsys = str(subsys)
               if subsys == 'carod' or subsys == 'condor_configd':
                  (retval, out, err) = run_cmd('condor_restart -subsystem %s' % subsys)
               else:
                  (retval, out, err) = run_cmd('%s -subsystem %s' % (cmd, subsys))
               if retval != 0:
                  log(logging.ERROR, self.logger_name, 'Failed to send command to subsystem "%s" (stdout: "%s", stderr: "%s")' % (subsys, out, err))
               else:
                  log(logging.INFO, self.logger_name, 'Sent command to subsystem "%s"' % subsys)


class Service:
   def __init__(self):
      self.broker_ip = ''
      self.broker_port = 5672
      self.broker = None
      self.console = None
      self.session = None
      self.store = []
      self.interval = 0
      self.node_obj = []
      self.logger_name = ''
      self.filename = ''
      self.node_name = ''
      self.timer = None
      self.lock = threading.Lock()


   def init(self, node, name):
      self.console = EventConsole()
      self.session = Session(self.console, manageConnections=False, rcvObjects=False, rcvHeartbeats=False, rcvEvents=True)
      self.session.addEventFilter(package='com.redhat.grid.config', event='WallabyConfigEvent')
      self.logger_name = name
      self.node_name = node
      self.managedfile = ''


   def config(self, filename):
      if self.broker != None:
         self.session.delBroker(self.broker)
         self.broker = None

      if self.store != []:
         self.store = []

      try:
         val = read_condor_config('QMF_BROKER', ['HOST'])
         self.broker_ip = val['host']
      except ConfigError, error:
         # Broker host not defined, so exit
         log(logging.ERROR, self.logger_name, '%s.  Exiting' % error.msg)
         return(False)

      try:
         val = read_condor_config('QMF_BROKER', ['PORT'])
         self.broker_port = val['port']
      except ConfigError, error:
         log(logging.INFO, self.logger_name, '%s. Using default (5672)' % error.msg)
         self.broker_port = 5672

      try:
         val = read_condor_config('QMF_CONFIGD', ['CHECK_INTERVAL'])
         self.interval = int(val['check_interval'])
      except ConfigError, error:
         log(logging.INFO, self.logger_name, '%s. Node configuration evaluation disabled' % error.msg)
         self.interval = 0

      if filename == '':
         try:
            loc = read_condor_config('LOCAL_CONFIG', ['DIR'])
            self.managedfile = '%s/00wallaby_node.config' % loc['dir']
         except:
            log(logging.ERROR, self.logger_name, 'LOCAL_CONFIG_DIR not defined.  Unable to write config')
            return(False)
      else:
         self.managedfile = filename
       
      return(self.config_qmf_entities())


   def config_qmf_entities(self):
      if self.broker != None:
         try:
            self.session.delBroker(self.broker)
         except:
            self.broker = None

      if self.node_obj != None:
         self.node_obj = None

      try:
         self.broker = self.session.addBroker('amqp://%s:%s' % (self.broker_ip, self.broker_port))
      except:
         log(logging.CRITICAL, self.logger_name, 'Unable to connect to broker "%s"' % self.broker_ip)
         return(False)

      try:
         obj = self.session.getObjects(_class='Store', _package='com.redhat.grid.config')
      except:
         obj = []

      if obj == []:
         log(logging.CRITICAL, self.logger_name, 'Failed to contact configuration store')
         return(False)

      self.store = obj[0]
      result = self.store.getNode(self.node_name)
      if result.status != 0:
         log(logging.CRITICAL, self.logger_name, '(%d, %s): Store does not know about this node' % (result.status, result.text))
         return(False)
      else:
         try:
            obj = self.session.getObjects(_objectId=result.outArgs['obj'])
         except:
            obj = []

         if obj == []:
            log(logging.CRITICAL, self.logger_name, 'Unable to get node information object')
            return(False)
         else:
            self.node_obj = obj[0]
            log(logging.INFO, self.logger_name, 'Retrieved node object from store')
      self.console.config(self.node_obj, self.logger_name, self.managedfile, self.lock)
      return(True)


   def setup_timers(self):
      # Setup the timer for checking configuration version
      if self.timer == None:
         if self.interval > 0:
            self.timer = Timer(self.interval, self.check_config_ver)
            self.timer.start()


   def shutdown(self):
      if self.timer != None:
         self.timer.stop()
         del self.timer
         self.timer = None
      if self.broker != None:
         self.session.delBroker(self.broker)
         self.broker = None


   def get_interval(self):
      return self.interval


   def check_config_ver(self, force=False):
      log(logging.INFO, self.logger_name, 'Periodically checking version of condor configuration')
      if self.node_obj == []:
         log(logging.ERROR, self.logger_name, 'No node object from the store')
         self.config_qmf_entities()
         return(1)

      try:
         val = read_condor_config('WALLABY_CONFIG', ['VERSION'], {'CONDOR_CONFIG':self.managedfile})
         version = int(val['version'])
      except ConfigError, error:
         # Never been configured before
         version = -1
      try:
         self.node_obj.update()
      except:
         # Agent/broker has gone away
         if self.config_qmf_entities() == False:
            return(1)

      wallaby_ver = self.node_obj.last_updated_version
      if version != wallaby_ver or force == True:
         log(logging.INFO, self.logger_name, 'Periodic checkin has discovered a newer configuation version (%d != %d)' % (version, wallaby_ver))
         get_config(self.node_obj, self.lock, self.logger_name, self.managedfile, wallaby_ver)
      else:
         log(logging.INFO, self.logger_name, 'Periodic checkin causing store checkin')
         self.lock.acquire(True)
         self.node_obj.checkin()
         self.lock.release()
         log(logging.INFO, self.logger_name, 'Periodic store checkin completed')


def get_config(node_obj, lock_obj, log_name, managedfile, version=0):
   global replacing_file

   log(logging.INFO, log_name, 'Retrieving configuration version "%d" from the store' % version)
   lock_obj.acquire(True)

   # Retrieve the node's configuration
   try:
      if version <= 0:
         result = node_obj.getConfig({})
      else:
         result = node_obj.getConfig({'version':version})
   except:
      # Something has gone away, so fail silently
      log(logging.ERROR, log_name, 'Exception when attempting to retrieve configuration version "%d" from the store' % version)
      lock_obj.release()
      return

   if result.status != 0:
      # Problem getting the configuration, so do nothing
      log(logging.ERROR, log_name, 'Failed to retrieve configuration "%d" from the store (%d, %s)' % (version, result.status, result.text))
      lock_obj.release()
      return
   else:
      config = result.outArgs['config']

   try:
      (file_hdl,file_name) = tempfile.mkstemp('.tmp', 'condor_config.local', text=True)
      for key in config.keys():
         os.write(file_hdl, '%s = %s\n' % (key, config[key]))
      os.close(file_hdl)
   except:
      log(logging.ERROR, log_name, 'Failed to write configuration to temp file')
      lock_obj.release()
      return

   # Verify the config file is valid
   (retval, out, err) = run_cmd('condor_config_val -dump', environ={'CONDOR_CONFIG':'%s' % file_name})
   if retval != 0:
      log(logging.ERROR, log_name, 'Configuration is invalid.  Discarding')
      os.remove(file_name)
      lock_obj.release()
      return

   # Install the file for condor to use
   replacing_file = True
   if os.path.exists(managedfile):
      os.remove(managedfile)
   try:
      shutil.move(file_name, managedfile)
   except:
      log(logging.ERROR, log_name, 'Error installing new configuration file')
      os.remove(file_name)
      replacing_file = False
      lock_obj.release()
      return
      
   replacing_file = False
   log(logging.INFO, log_name, 'Retrieved configuration from the store')
   log(logging.INFO, log_name, 'Performing a checkin with the store')
   try:
      node_obj.checkin()
   except:
      log(logging.INFO, log_name, 'Failed to check in with the store')
      lock_obj.release()
      return
   log(logging.INFO, log_name, 'Checked in with the store')
   lock_obj.release()


def exit_signal_handler(signum, frame):
   global service, stop_running

   if service != None:
      service.shutdown()
      del service
      service = None
   logging.shutdown()
   stop_running = True

def test_for_shutdown():
	pidfile = os.getcwd() + '\\.pid' + str(os.getpid())
	if os.path.isfile(pidfile):
		os.remove(pidfile)
		exit_signal_handler(signal.SIGTERM, None)

service = Service()
stop_running = False
replacing_file = False

def main(argv=None):
   global service, stop_running, replacing_file

   if argv is None:
      argv = sys.argv

   try:
      file = {}
      retrieve = False
      logger_name = os.path.basename(argv[0])
      node_name = socket.gethostname()
      config_file = ''

      long_opts = ['hostname=', 'logfile=', 'managedfile=', 'retrieve']
      try:
         opts, args = getopt.gnu_getopt(argv[1:], 'h:l:m:r', long_opts)
      except getopt.GetoptError, error:
         print str(error)
         return(1)

      for option, arg in opts:
         if option in ('-h', '--hostname'):
            node_name = arg
         if option in ('-l', '--logfile'):
            file['log'] = arg
         if option in ('-m', '--managedfile'):
            config_file = arg
         if option in ('-r', '--retrieve'):
            retrieve = True

      # Configure the logging system
      if 'log' not in file.keys():
         try:
            file = read_condor_config('QMF_CONFIGD', ['LOG'])
         except ConfigError, error:
            print 'Error: %s.  Exiting' % error.msg
            return(1)

      try:
         size = int(read_condor_config('MAX_QMF_CONFIGD', ['LOG'])['log'])
      except:
         size = 1000000

      try:
         base_logger = create_file_logger(logger_name, file['log'], logging.INFO, size=size)
      except:
         print 'Failed to open log file.  Exiting'
         return(1)

      # Set signal handlers
      signal.signal(signal.SIGINT, exit_signal_handler)
      signal.signal(signal.SIGTERM, exit_signal_handler)
      signal.signal(signal.SIGABRT, exit_signal_handler)
      signal.signal(signal.SIGILL, exit_signal_handler)
      signal.signal(signal.SIGFPE, exit_signal_handler)
      signal.signal(signal.SIGSEGV, exit_signal_handler)
      if os.name != 'nt' and os.name != 'ce':
         # These aren't available on windows
         signal.signal(signal.SIGQUIT, exit_signal_handler)
      if os.name == 'nt':
         # need to set a Timer for shutdown
         log(logging.INFO, logger_name, 'Setting windows shutdown Timer')
         shutdown_interval = int(read_condor_config('QMF_CONFIGD', ['WIN_INTERVAL'])['win_interval'])
         shutdown_timer = Timer(shutdown_interval,test_for_shutdown)
         shutdown_timer.start()

      log(logging.INFO, logger_name, 'Starting Up')

      # Retrieve the broker information from condor's configuration file
      if service != None:
         service.init(node_name, logger_name)
      if service != None and service.config(config_file) != True:
         if retrieve == True:
            print 'Error: Unable to retrieve configuration'
            log(logging.CRITICAL, logger_name, 'Unable to retrieve configuration')
         exit_signal_handler(0, 0)
         return(1)
      elif retrieve == True:
         if service != None:
            service.check_config_ver(True)
         exit_signal_handler(0, 0)
         return(0)

      # Delay initial checkin after startup 
      random.seed()
      time.sleep(random.randint(0, 10))
      if service != None:
         service.check_config_ver()
      if service != None:
         service.setup_timers()

      # Loop forever until told to shutdown
      while stop_running == False or replacing_file == True:
         try:
            time.sleep(1)
         except:
            pass
   except KeyboardInterrupt:
      pass

if __name__ == '__main__':
    sys.exit(main())
