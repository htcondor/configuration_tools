#!/usr/bin/python
#   Copyright 2008 Red Hat, Inc.
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

import os
import sys
import logging
import signal
import time
import socket
import threading
import getopt
import random
import tempfile
import shutil
from qmf.console import Session, Console
from condorutils.log import *
from condorutils.readconfig import *


class Timer (threading.Thread):
   def __init__ (self, interval, function, args=[], kwargs={}):
      threading.Thread.__init__(self)
      self.interval = interval
      self.function = function
      self.args = args
      self.kwargs = kwargs
      self.setDaemon(True)
      self.finished = threading.Event()


   def stop (self):
      self.finished.set()
      self.join()


   def run (self):
      while not self.finished.isSet():
         self.finished.wait(self.interval)
         self.function(*self.args, **self.kwargs)


class EventConsole(Console):
   def __init__(self):
      self.node = []
      self.logger_name = ''
      self.name = ''
      self.managedfile = ''


   def config(self, obj, name, filename):
      self.node = obj
      self.logger_name = name
      self.managedfile = filename


   def event(self, broker, event):
      if event.getClassKey().getClassName() == 'WallabyConfigEvent':
         args = event.getArguments()
         affected_hosts = args['affectedNodes']
         if self.node.getIndex() in affected_hosts.keys():
            get_config(self.node, self.logger_name, self.managedfile, affected_hosts[self.node.getIndex()])
            if args['restart'] == True:
               cmd = 'condor_restart'
            else:
               cmd = 'condor_reconfig'

            targets = args['Targets']
            for subsys in targets['condor']:
               if subsys == 'carod' or subsys == 'condor_configd':
                  (retval, out, err) = run_cmd('condor_restart -subsystem %s' % subsys)
               else:
                  (retval, out, err) = run_cmd('%s -subsystem %s' % (cmd, subsys))
               if retval != 0:
                  log(logging.ERROR, self.logger_name, 'Failed to send command to subsystem "%s" (stdout: %s, stderr: %s)' % (subsys, out, err))
      elif event.getClassKey().getClassName() == 'NewConfigEvent':
#         print dir(event)
#         args = event.getArguments()
#         affected_hosts = args['nodelist']
#         if self.node.getIndex() in affected_hosts.keys():
         if True:
            get_config(self.node, self.logger_name, self.managedfile)
            (retval, out, err) = run_cmd('condor_restart -subsystem master')
            if retval != 0:
               log(logging.ERROR, self.logger_name, 'Failed to send command to subsystem "master" (stdout: %s, stderr: %s)' % (out, err))


class Service:
   def __init__(self):
      self.broker_ip = ''
      self.broker_port = 5672
      self.broker = None
      self.console = None
      self.session = None
      self.store = []
      self.interval = 0
      self.node_obj = []
      self.logger_name = ''
      self.filename = ''
      self.node_name = ''
      self.timer = None


   def init(self, node, name):
      self.console = EventConsole()
      self.session = Session(self.console, manageConnections=False, rcvObjects=False, rcvHeartbeats=False, rcvEvents=True)
      self.logger_name = name
      self.node_name = node
      self.managedfile = ''


   def config(self, filename):
      if self.broker != None:
         self.session.delBroker(self.broker)
         self.broker = None

      if self.store != []:
         self.store = []

      try:
         val = read_condor_config('QMF_BROKER', ['HOST'])
         self.broker_ip = val['host']
      except ConfigError, error:
         # Broker host not defined, so exit
         log(logging.ERROR, self.logger_name, '%s.  Exiting' % error.msg)
         return(False)

      try:
         val = read_condor_config('QMF_BROKER', ['PORT'])
         self.broker_port = val['port']
      except ConfigError, error:
         log(logging.INFO, self.logger_name, '%s. Using default (5672)' % error.msg)
         self.broker_port = 5672

      try:
         val = read_condor_config('QMF_CONFIGD', ['CHECK_INTERVAL'])
         self.interval = int(val['check_interval'])
      except ConfigError, error:
         log(logging.INFO, self.logger_name, '%s. Node configuration evaluation disabled' % error.msg)
         self.interval = 0

      if filename == '':
         try:
            loc = read_condor_config('LOCAL_CONFIG', ['DIR'])
            self.managedfile = '%s/00wallaby_node.config' % loc['dir']
         except:
            log(logging.ERROR, self.logger_name, 'LOCAL_CONFIG_DIR not defined.  Unable to write config')
            return(False)
      else:
         self.managedfile = filename
       
      try:
         self.broker = self.session.addBroker('amqp://%s:%s' % (self.broker_ip, self.broker_port))
      except:
         log(logging.CRITICAL, self.logger_name, 'Unable to connect to broker "%s"' % self.broker_ip)
         return(False)

      try:
         obj = self.session.getObjects(_class='Store', _package='mrg.grid.config')
      except:
         obj = []

      if obj == []:
         log(logging.CRITICAL, self.logger_name, 'Failed to contact configuration store.  Exiting')
         return(False)

      self.store = obj[0]
      result = self.store.getNode(self.node_name)
      if result.status != 0:
         log(logging.CRITICAL, self.logger_name, '(%d, %s): Store does not know about this node' % (result.status, result.text))
         return(False)
      else:
         try:
            obj = self.session.getObjects(_objectId=result.outArgs['obj'])
         except:
            obj = []

         if obj == []:
            log(logging.CRITICAL, self.logger_name, 'Unable to get node information object')
            return(False)
         else:
            self.node_obj = obj[0]
            log(logging.INFO, self.logger_name, 'Retrieved node object from store')
      self.console.config(self.node_obj, self.logger_name, self.managedfile)

      return(True)


   def setup_timers(self):
      # Setup the timer for checking configuration version
      if self.timer == None:
         if self.interval > 0:
            self.timer = Timer(self.interval, self.check_config_ver)
            self.timer.start()


   def shutdown(self):
      if self.timer != None:
         self.timer.stop()
         del self.timer
         self.timer = None
      if self.broker != None:
         self.session.delBroker(self.broker)
         self.broker = None


   def get_interval(self):
      return self.interval


   def check_config_ver(self):
      log(logging.INFO, self.logger_name, 'Checking version of condor configuration')
      if self.node_obj == []:
         log(logging.ERROR, self.logger_name, 'No node object from the store')
         return(1)

      try:
         val = read_condor_config('WALLABY_CONFIG', ['VERSION'], {'CONDOR_CONFIG':self.managedfile})
         version = int(val['version'])
      except ConfigError, error:
         # Never been configured before, so send a bank version
         version = -1
      self.node_obj.update()
      wallaby_ver = self.node_obj.last_updated_version
      if version != wallaby_ver:
         get_config(self.node_obj, self.logger_name, self.managedfile, wallaby_ver)
         log(logging.INFO, self.logger_name, 'Retrieved new configuration from the store(%d!=%d)' % (version, new_version))
      else:
         self.node_obj.checkin()


def get_config(node_obj, log_name, managedfile, version=''):
   global replacing_file

   # Retrieve the node's configuration
   result = node_obj.getConfig(version)
   if result.status != 0:
      # Problem getting the configuration, so do nothing
      log(logging.ERROR, log_name, 'Failed to retrieve configuration from the store (%d, %s)' % (result.status, result.text))
      return
   else:
      config = result.outArgs['config']

   (temp_file,name) = tempfile.mkstemp('.tmp', 'condor_config.local', text=True)
   for key in config.keys():
      os.write(temp_file, '%s = %s\n' % (key, config[key]))
   os.close(temp_file)

   # Verify the config file is valid
   (retval, out, err) = run_cmd('condor_config_val -dump', environ={'CONDOR_CONFIG':'%s' % name})
   if retval != 0:
      log(logging.ERROR, log_name, 'Configuration is invalid.  Discarding')
      os.remove(name)
      return

   # Install the file for condor to use
   replacing_file = True
   if os.path.exists(managedfile):
      os.remove(managedfile)
   shutil.move(name, managedfile)
   replacing_file = False

   node_obj.checkin()


def exit_signal_handler(signum, frame):
   global service, stop_running

   service.shutdown()
   del service
   logging.shutdown()
   stop_running = True


service = Service()
stop_running = False
replacing_file = False

def main(argv=None):
   global service, stop_running, replacing_file

   if argv is None:
      argv = sys.argv

   try:
      file = {}
      retrieve = False
      logger_name = os.path.basename(argv[0])
      node_name = socket.gethostname()
      config_file = ''

      long_opts = ['hostname=', 'logfile=', 'managedfile=', 'retrieve']
      try:
         opts, args = getopt.gnu_getopt(argv[1:], 'h:l:m:r', long_opts)
      except getopt.GetoptError, error:
         print str(error)
         return(1)

      for option, arg in opts:
         if option in ('-h', '--hostname'):
            node_name = arg
         if option in ('-l', '--logfile'):
            file['log'] = arg
         if option in ('-m', '--managedfile'):
            config_file = arg
         if option in ('-r', '--retrieve'):
            retrieve = True

      # Configure the logging system
      if 'log' not in file.keys():
         try:
            file = read_condor_config('QMF_CONFIGD', ['LOG'])
         except ConfigError, error:
            print 'Error: %s.  Exiting' % error.msg
            return(1)

      try:
         size = int(read_condor_config('MAX_QMF_CONFIGD', ['LOG'])['log'])
      except:
         size = 1000000

      base_logger = create_file_logger(logger_name, file['log'], logging.INFO, size=size)

      # Set signal handlers
      signal.signal(signal.SIGINT, exit_signal_handler)
      signal.signal(signal.SIGTERM, exit_signal_handler)

      log(logging.INFO, logger_name, 'Starting Up')

      # Retrieve the broker information from condor's configuration file
      service.init(node_name, logger_name)
      if service.config(config_file) != True:
         if retrieve == True:
            print 'Error: Unable to retrieve configuration'
            log(logging.CRITICAL, logger_name, 'Unable to retrieve configuration')
         return(1)
      elif retrieve == True:
         service.check_config_ver()
         logging.shutdown()
         return(0)

      # Delay initial checkin after startup 
      random.seed()
      time.sleep(random.randint(0, 10))
      service.check_config_ver()
      service.setup_timers()

      # Loop forever until told to shutdown
      while stop_running == False or replacing_file == True:
         try:
            time.sleep(1)
         except:
            pass
   except KeyboardInterrupt:
      pass

if __name__ == '__main__':
    sys.exit(main())
